{"version":3,"sources":["skylark-widgets-filer.js"],"names":["define","skylark","attach","types","objects","arrays","Deferred","Xhr","params","xoptions","mixin","contentRange","paramName","undefined","singleFileUploads","limitMultiFileUploads","limitMultiFileUploadSize","limitMultiFileUploadSizeOverhead","sequentialUploads","limitConcurrentUploads","multipart","maxChunkSize","uploadedBytes","recalculateProgress","progressInterval","bitrateInterval","autoUpload","messages","i18n","message","context","this","toString","each","key","value","replace","formData","form","serializeArray","add","e","data","isDefaultPrevented","$","fileupload","process","done","submit","processData","contentType","cache","blobSlice","slice","Blob","prototype","webkitSlice","mozSlice","apply","arguments","ajax","request","url","initXHRData","o","file","files","type","headers","FormData","blob","append","name","index","uploadName","encodeURI","chunkedUpload","options","testOnly","jqXHR","upload","fs","size","ub","mcs","dfd","promise","error","_getXHRPromise","currentLoaded","_progress","loaded","call","chunkSize","result","textStatus","range","getResponseHeader","parts","split","upperBytesPos","length","parseInt","getUploadedBytes","progress","lengthComputable","total","resolveWith","fail","errorThrown","rejectWith","abort","_bitrateTimer","timestamp","Date","now","getTime","bitrate","getBitrate","interval","timeDiff","jqXhr","langx","eventer","dropzone","pastezone","picker","FileUploader","Evented","inherit","dropZone","document","pasteZone","postMessage","option","_specialOptions","_BitrateTimer","_getTotal","_initProgressObject","obj","extend","_initResponseObject","prop","_response","hasOwnProperty","_onProgress","_time","Math","floor","_trigger","create","delegatedEvent","_getParamName","isArray","_getDeferredState","deferred","state","isResolved","isRejected","_enhancePromise","success","complete","always","resolveOrReject","args","_addConvenienceMethods","that","getPromise","resolveFunc","rejectFunc","_processQueue","pipe","_onSend","processing","response","_beforeSend","_active","_onDone","_onFail","event","proxy","trigger","_onAlways","jqXHRorResult","jqXHRorError","_sending","dataType","xhrFields","_onAdd","paramNameSet","paramNameSlice","fileSet","i","filesLength","limit","limitSize","overhead","batchSize","j","push","originalFiles","element","newData","_initEventHandlers","dropped","pasted","multiple","picked","_destroyEventHandlers","_setOption","reinit","inArray","_super","_initSpecialOptions","_elm","_getRegExp","str","modifiers","pop","shift","RegExp","join","_isRegExpOption","test","_construct","elm","_slots","_sequence","active","disabled","makeArray","send","fuInst","on","evt","typ","isFunction","ArrayList","uploader","Widget","filer","displaySize","bytes","log","pow","toFixed","displayDate","toLocaleString","FileItem","Stateful","start","isPending","get","cancel","destroy","getState","isRunning","isDone","isError","FileItemCollection","item","FileItemWidget","className","selectors","fileName","fileSize","clear","String","Number","_init","processUploadMsg","doneMsg","model","close","updateProgress","hasFailed","hasDone","update","_refresh","updates","percent","progressHTML","_velm","find","css","parent","html","when_pending","when_running","when_done","addClass","removeClass","_startup","self","click","collection","remove","computeData","Uploader","klassName","pluginName","uploadUrl","fileList","nodata","pickFiles","startUploads","cancelUploads","fileItem","template","filePicker","_files","uploadProcess","uploadManagerFiles","file_data","id","file_id","processor","renderFile","bindProcessEvents","at","forEach","with_files_elements","without_files_elements","count","file_view","render","main"],"mappings":"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","file":"../skylark-widgets-filer.js","sourcesContent":["define('skylark-widgets-filer/filer',[\r\n\t\"skylark-langx/skylark\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"widgets.filer\",{});\r\n});\ndefine('skylark-widgets-filer/domx/upload',[\r\n    \"skylark-langx/types\",\r\n    \"skylark-langx/objects\",\r\n    \"skylark-langx/arrays\",\r\n    \"skylark-langx/Deferred\",\r\n    \"skylark-langx/Xhr\"\r\n],function(types, objects, arrays, Deferred,Xhr){\r\n\r\n    function upload(params) {\r\n        var xoptions = objects.mixin({\r\n            contentRange: null, //\r\n\r\n            // The parameter name for the file form data (the request argument name).\r\n            // If undefined or empty, the name property of the file input field is\r\n            // used, or \"files[]\" if the file input name property is also empty,\r\n            // can be a string or an array of strings:\r\n            paramName: undefined,\r\n            // By default, each file of a selection is uploaded using an individual\r\n            // request for XHR type uploads. Set to false to upload file\r\n            // selections in one request each:\r\n            singleFileUploads: true,\r\n            // To limit the number of files uploaded with one XHR request,\r\n            // set the following option to an integer greater than 0:\r\n            limitMultiFileUploads: undefined,\r\n            // The following option limits the number of files uploaded with one\r\n            // XHR request to keep the request size under or equal to the defined\r\n            // limit in bytes:\r\n            limitMultiFileUploadSize: undefined,\r\n            // Multipart file uploads add a number of bytes to each uploaded file,\r\n            // therefore the following option adds an overhead for each file used\r\n            // in the limitMultiFileUploadSize configuration:\r\n            limitMultiFileUploadSizeOverhead: 512,\r\n            // Set the following option to true to issue all file upload requests\r\n            // in a sequential order:\r\n            sequentialUploads: false,\r\n            // To limit the number of concurrent uploads,\r\n            // set the following option to an integer greater than 0:\r\n            limitConcurrentUploads: undefined,\r\n            // By default, XHR file uploads are sent as multipart/form-data.\r\n            // The iframe transport is always using multipart/form-data.\r\n            // Set to false to enable non-multipart XHR uploads:\r\n            multipart: true,\r\n            // To upload large files in smaller chunks, set the following option\r\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\r\n            // or the browser does not support the required Blob API, files will\r\n            // be uploaded as a whole.\r\n            maxChunkSize: undefined,\r\n            // When a non-multipart upload or a chunked multipart upload has been\r\n            // aborted, this option can be used to resume the upload by setting\r\n            // it to the size of the already uploaded bytes. This option is most\r\n            // useful when modifying the options object inside of the \"add\" or\r\n            // \"send\" callbacks, as the options are cloned for each file upload.\r\n            uploadedBytes: undefined,\r\n            // By default, failed (abort or error) file uploads are removed from the\r\n            // global progress calculation. Set the following option to false to\r\n            // prevent recalculating the global progress data:\r\n            recalculateProgress: true,\r\n            // Interval in milliseconds to calculate and trigger progress events:\r\n            progressInterval: 100,\r\n            // Interval in milliseconds to calculate progress bitrate:\r\n            bitrateInterval: 500,\r\n            // By default, uploads are started automatically when adding files:\r\n            autoUpload: true,\r\n\r\n            // Error and info messages:\r\n            messages: {\r\n                uploadedBytes: 'Uploaded bytes exceed file size'\r\n            },\r\n\r\n            // Translation function, gets the message key to be translated\r\n            // and an object with context specific data as arguments:\r\n            i18n: function(message, context) {\r\n                message = this.messages[message] || message.toString();\r\n                if (context) {\r\n                    objects.each(context, function(key, value) {\r\n                        message = message.replace('{' + key + '}', value);\r\n                    });\r\n                }\r\n                return message;\r\n            },\r\n\r\n            // Additional form data to be sent along with the file uploads can be set\r\n            // using this option, which accepts an array of objects with name and\r\n            // value properties, a function returning such an array, a FormData\r\n            // object (for XHR file uploads), or a simple object.\r\n            // The form of the first fileInput is given as parameter to the function:\r\n            formData: function(form) {\r\n                return form.serializeArray();\r\n            },\r\n\r\n            // The add callback is invoked as soon as files are added to the fileupload\r\n            // widget (via file input selection, drag & drop, paste or add API call).\r\n            // If the singleFileUploads option is enabled, this callback will be\r\n            // called once for each file in the selection for XHR file uploads, else\r\n            // once for each file selection.\r\n            //\r\n            // The upload starts when the submit method is invoked on the data parameter.\r\n            // The data object contains a files property holding the added files\r\n            // and allows you to override plugin options as well as define ajax settings.\r\n            //\r\n            // Listeners for this callback can also be bound the following way:\r\n            // .bind('fileuploadadd', func);\r\n            //\r\n            // data.submit() returns a Promise object and allows to attach additional\r\n            // handlers using jQuery's Deferred callbacks:\r\n            // data.submit().done(func).fail(func).always(func);\r\n            add: function(e, data) {\r\n                if (e.isDefaultPrevented()) {\r\n                    return false;\r\n                }\r\n                if (data.autoUpload || (data.autoUpload !== false &&\r\n                        $(this).fileupload('option', 'autoUpload'))) {\r\n                    data.process().done(function() {\r\n                        data.submit();\r\n                    });\r\n                }\r\n            },\r\n\r\n            // Other callbacks:\r\n\r\n            // Callback for the submit event of each file upload:\r\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\r\n\r\n            // Callback for the start of each file upload request:\r\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\r\n\r\n            // Callback for successful uploads:\r\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\r\n\r\n            // Callback for failed (abort or error) uploads:\r\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\r\n\r\n            // Callback for completed (success, abort or error) requests:\r\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\r\n\r\n            // Callback for upload progress events:\r\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\r\n\r\n            // Callback for global upload progress events:\r\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\r\n\r\n            // Callback for uploads start, equivalent to the global ajaxStart event:\r\n            // start: function (e) {}, // .bind('fileuploadstart', func);\r\n\r\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\r\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\r\n\r\n            // Callback for change events of the fileInput(s):\r\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\r\n\r\n            // Callback for paste events to the pasteZone(s):\r\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\r\n\r\n            // Callback for drop events of the dropZone(s):\r\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\r\n\r\n            // Callback for dragover events of the dropZone(s):\r\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\r\n\r\n            // Callback for the start of each chunk upload request:\r\n            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\r\n\r\n            // Callback for successful chunk uploads:\r\n            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\r\n\r\n            // Callback for failed (abort or error) chunk uploads:\r\n            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\r\n\r\n            // Callback for completed (success, abort or error) chunk upload requests:\r\n            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\r\n\r\n            // The plugin options are used as settings object for the ajax calls.\r\n            // The following are jQuery ajax settings required for the file uploads:\r\n            processData: false,\r\n            contentType: false,\r\n            cache: false\r\n        }, params);\r\n\r\n        var blobSlice = function() {\r\n                var slice = Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice;\r\n                return slice.apply(this, arguments);\r\n            },\r\n            ajax = function(data) {\r\n                return Xhr.request(data.url, data);\r\n            };\r\n\r\n        function initDataSettings(o) {\r\n            o.type = o.type || \"POST\";\r\n\r\n            if (!chunkedUpload(o, true)) {\r\n                if (!o.data) {\r\n                    initXHRData(o);\r\n                }\r\n                //initProgressListener(o);\r\n            }\r\n        }\r\n\r\n        function initXHRData(o) {\r\n            var that = this,\r\n                formData,\r\n                file = o.files[0],\r\n                // Ignore non-multipart setting if not supported:\r\n                multipart = o.multipart,\r\n                paramName = types.type(o.paramName) === 'array' ?\r\n                o.paramName[0] : o.paramName;\r\n\r\n            o.headers = objects.mixin({}, o.headers);\r\n            if (o.contentRange) {\r\n                o.headers['Content-Range'] = o.contentRange;\r\n            }\r\n            if (!multipart) {\r\n                o.headers['Content-Disposition'] = 'attachment; filename=\"' +\r\n                    encodeURI(file.name) + '\"';\r\n                o.contentType = file.type || 'application/octet-stream';\r\n                o.data = o.blob || file;\r\n            } else {\r\n                formData = new FormData();\r\n                if (o.blob) {\r\n                    formData.append(paramName, o.blob, file.name);\r\n                } else {\r\n                    objects.each(o.files, function(index, file) {\r\n                        // This check allows the tests to run with\r\n                        // dummy objects:\r\n                        formData.append(\r\n                            (types.type(o.paramName) === 'array' &&\r\n                                o.paramName[index]) || paramName,\r\n                            file,\r\n                            file.uploadName || file.name\r\n                        );\r\n                    });\r\n                }\r\n                o.data = formData;\r\n            }\r\n            // Blob reference is not needed anymore, free memory:\r\n            o.blob = null;\r\n        }\r\n\r\n        function getTotal(files) {\r\n            var total = 0;\r\n            objects.each(files, function(index, file) {\r\n                total += file.size || 1;\r\n            });\r\n            return total;\r\n        }\r\n\r\n        function getUploadedBytes(jqXHR) {\r\n            var range = jqXHR.getResponseHeader('Range'),\r\n                parts = range && range.split('-'),\r\n                upperBytesPos = parts && parts.length > 1 &&\r\n                parseInt(parts[1], 10);\r\n            return upperBytesPos && upperBytesPos + 1;\r\n        }\r\n\r\n        function initProgressObject(obj) {\r\n            var progress = {\r\n                loaded: 0,\r\n                total: 0,\r\n                bitrate: 0\r\n            };\r\n            if (obj._progress) {\r\n                objects.mixin(obj._progress, progress);\r\n            } else {\r\n                obj._progress = progress;\r\n            }\r\n        }\r\n\r\n        function BitrateTimer() {\r\n            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());\r\n            this.loaded = 0;\r\n            this.bitrate = 0;\r\n            this.getBitrate = function(now, loaded, interval) {\r\n                var timeDiff = now - this.timestamp;\r\n                if (!this.bitrate || !interval || timeDiff > interval) {\r\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\r\n                    this.loaded = loaded;\r\n                    this.timestamp = now;\r\n                }\r\n                return this.bitrate;\r\n            };\r\n        }\r\n\r\n        function chunkedUpload(options, testOnly) {\r\n            options.uploadedBytes = options.uploadedBytes || 0;\r\n            var that = this,\r\n                file = options.files[0],\r\n                fs = file.size,\r\n                ub = options.uploadedBytes,\r\n                mcs = options.maxChunkSize || fs,\r\n                slice = blobSlice,\r\n                dfd = new Deferred(),\r\n                promise = dfd.promise,\r\n                jqXHR,\r\n                upload;\r\n            if (!(slice && (ub || mcs < fs)) ||\r\n                options.data) {\r\n                return false;\r\n            }\r\n            if (testOnly) {\r\n                return true;\r\n            }\r\n            if (ub >= fs) {\r\n                file.error = options.i18n('uploadedBytes');\r\n                return this._getXHRPromise(\r\n                    false,\r\n                    options.context, [null, 'error', file.error]\r\n                );\r\n            }\r\n            // The chunk upload method:\r\n            upload = function() {\r\n                // Clone the options object for each chunk upload:\r\n                var o = objects.mixin({}, options),\r\n                    currentLoaded = o._progress.loaded;\r\n                o.blob = slice.call(\r\n                    file,\r\n                    ub,\r\n                    ub + mcs,\r\n                    file.type\r\n                );\r\n                // Store the current chunk size, as the blob itself\r\n                // will be dereferenced after data processing:\r\n                o.chunkSize = o.blob.size;\r\n                // Expose the chunk bytes position range:\r\n                o.contentRange = 'bytes ' + ub + '-' +\r\n                    (ub + o.chunkSize - 1) + '/' + fs;\r\n                // Process the upload data (the blob and potential form data):\r\n                initXHRData(o);\r\n                // Add progress listeners for this chunk upload:\r\n                //initProgressListener(o);\r\n                jqXHR = ajax(o).done(function(result, textStatus, jqXHR) {\r\n                        ub = getUploadedBytes(jqXHR) ||\r\n                            (ub + o.chunkSize);\r\n                        // Create a progress event if no final progress event\r\n                        // with loaded equaling total has been triggered\r\n                        // for this chunk:\r\n                        if (currentLoaded + o.chunkSize - o._progress.loaded) {\r\n                            dfd.progress({\r\n                                lengthComputable: true,\r\n                                loaded: ub - o.uploadedBytes,\r\n                                total: ub - o.uploadedBytes\r\n                            });\r\n                        }\r\n                        options.uploadedBytes = o.uploadedBytes = ub;\r\n                        o.result = result;\r\n                        o.textStatus = textStatus;\r\n                        o.jqXHR = jqXHR;\r\n                        //that._trigger('chunkdone', null, o);\r\n                        //that._trigger('chunkalways', null, o);\r\n                        if (ub < fs) {\r\n                            // File upload not yet complete,\r\n                            // continue with the next chunk:\r\n                            upload();\r\n                        } else {\r\n                            dfd.resolveWith(\r\n                                o.context, [result, textStatus, jqXHR]\r\n                            );\r\n                        }\r\n                    })\r\n                    .fail(function(jqXHR, textStatus, errorThrown) {\r\n                        o.jqXHR = jqXHR;\r\n                        o.textStatus = textStatus;\r\n                        o.errorThrown = errorThrown;\r\n                        //that._trigger('chunkfail', null, o);\r\n                        //that._trigger('chunkalways', null, o);\r\n                        dfd.rejectWith(\r\n                            o.context, [jqXHR, textStatus, errorThrown]\r\n                        );\r\n                    });\r\n            };\r\n            //this._enhancePromise(promise);\r\n            promise.abort = function() {\r\n                return jqXHR.abort();\r\n            };\r\n            upload();\r\n            return promise;\r\n        }\r\n\r\n        initDataSettings(xoptions);\r\n\r\n        xoptions._bitrateTimer = new BitrateTimer();\r\n\r\n        var jqXhr = chunkedUpload(xoptions) || ajax(xoptions);\r\n\r\n        jqXhr.options = xoptions;\r\n\r\n        return jqXhr;\r\n    }\r\n\r\n    return upload;  \r\n});\ndefine('skylark-widgets-filer/domx/uploader',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-eventer\",\r\n    \"skylark-domx-query\",\r\n    \"skylark-domx-files/dropzone\",\r\n    \"skylark-domx-files/pastezone\",\r\n    \"skylark-domx-files/picker\",\r\n    \"./upload\"\r\n],function (langx,eventer,$,dropzone,pastezone,picker,upload) {\r\n    'use strict';\r\n\r\n    var Deferred = langx.Deferred;\r\n\r\n\r\n    // The fileupload widget listens for change events on file input fields defined\r\n    // via fileInput setting and paste or drop events of the given dropZone.\r\n    // In addition to the default jQuery Widget methods, the fileupload widget\r\n    // exposes the \"add\" and \"send\" methods, to add or directly send files using\r\n    // the fileupload API.\r\n    // By default, files added via file input selection, paste, drag & drop or\r\n    // \"add\" method are uploaded immediately, but it is possible to override\r\n    // the \"add\" callback option to queue file uploads.\r\n\r\n    var FileUploader = langx.Evented.inherit( {\r\n\r\n        options: {\r\n            // The drop target element(s), by the default the complete document.\r\n            // Set to null to disable drag & drop support:\r\n            dropZone: $(document),\r\n\r\n            // The paste target element(s), by the default the complete document.\r\n            // Set to null to disable paste support:\r\n            pasteZone: $(document),\r\n\r\n            // The file input field(s), that are listened to for change events.\r\n            // If undefined, it is set to the file input fields inside\r\n            // of the widget element on plugin initialization.\r\n            // Set to null to disable the change listener.\r\n            picker: undefined,\r\n\r\n\r\n            // The parameter name for the file form data (the request argument name).\r\n            // If undefined or empty, the name property of the file input field is\r\n            // used, or \"files[]\" if the file input name property is also empty,\r\n            // can be a string or an array of strings:\r\n            paramName: undefined,\r\n            \r\n            // By default, each file of a selection is uploaded using an individual\r\n            // request for XHR type uploads. Set to false to upload file\r\n            // selections in one request each:\r\n            singleFileUploads: true,\r\n            \r\n            // To limit the number of files uploaded with one XHR request,\r\n            // set the following option to an integer greater than 0:\r\n            limitMultiFileUploads: undefined,\r\n            \r\n            // The following option limits the number of files uploaded with one\r\n            // XHR request to keep the request size under or equal to the defined\r\n            // limit in bytes:\r\n            limitMultiFileUploadSize: undefined,\r\n\r\n            // Multipart file uploads add a number of bytes to each uploaded file,\r\n            // therefore the following option adds an overhead for each file used\r\n            // in the limitMultiFileUploadSize configuration:\r\n            limitMultiFileUploadSizeOverhead: 512,\r\n\r\n            // Set the following option to true to issue all file upload requests\r\n            // in a sequential order:\r\n            sequentialUploads: false,\r\n            \r\n            // To limit the number of concurrent uploads,\r\n            // set the following option to an integer greater than 0:\r\n            limitConcurrentUploads: undefined,\r\n\r\n            // Set the following option to the location of a postMessage window,\r\n            // to enable postMessage transport uploads:\r\n            postMessage: undefined,\r\n \r\n            // By default, XHR file uploads are sent as multipart/form-data.\r\n            // The iframe transport is always using multipart/form-data.\r\n            // Set to false to enable non-multipart XHR uploads:\r\n            multipart: true,\r\n \r\n            // To upload large files in smaller chunks, set the following option\r\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\r\n            // or the browser does not support the required Blob API, files will\r\n            // be uploaded as a whole.\r\n            maxChunkSize: undefined,\r\n \r\n            // When a non-multipart upload or a chunked multipart upload has been\r\n            // aborted, this option can be used to resume the upload by setting\r\n            // it to the size of the already uploaded bytes. This option is most\r\n            // useful when modifying the options object inside of the \"add\" or\r\n            // \"send\" callbacks, as the options are cloned for each file upload.\r\n            uploadedBytes: undefined,\r\n \r\n            // By default, failed (abort or error) file uploads are removed from the\r\n            // global progress calculation. Set the following option to false to\r\n            // prevent recalculating the global progress data:\r\n            recalculateProgress: true,\r\n \r\n            // Interval in milliseconds to calculate and trigger progress events:\r\n            progressInterval: 100,\r\n \r\n            // Interval in milliseconds to calculate progress bitrate:\r\n            bitrateInterval: 500,\r\n \r\n            // By default, uploads are started automatically when adding files:\r\n            autoUpload: false,\r\n\r\n            // Error and info messages:\r\n            messages: {\r\n                uploadedBytes: 'Uploaded bytes exceed file size'\r\n            },\r\n\r\n            // Translation function, gets the message key to be translated\r\n            // and an object with context specific data as arguments:\r\n            i18n: function (message, context) {\r\n                message = this.messages[message] || message.toString();\r\n                if (context) {\r\n                    langx.each(context, function (key, value) {\r\n                        message = message.replace('{' + key + '}', value);\r\n                    });\r\n                }\r\n                return message;\r\n            },\r\n\r\n            // Additional form data to be sent along with the file uploads can be set\r\n            // using this option, which accepts an array of objects with name and\r\n            // value properties, a function returning such an array, a FormData\r\n            // object (for XHR file uploads), or a simple object.\r\n            // The form of the first fileInput is given as parameter to the function:\r\n            formData: function (form) {\r\n                return form.serializeArray();\r\n            },\r\n\r\n            // The add callback is invoked as soon as files are added to the fileupload\r\n            // widget (via file input selection, drag & drop, paste or add API call).\r\n            // If the singleFileUploads option is enabled, this callback will be\r\n            // called once for each file in the selection for XHR file uploads, else\r\n            // once for each file selection.\r\n            //\r\n            // The upload starts when the submit method is invoked on the data parameter.\r\n            // The data object contains a files property holding the added files\r\n            // and allows you to override plugin options as well as define ajax settings.\r\n            //\r\n            // Listeners for this callback can also be bound the following way:\r\n            // .bind('fileuploadadd', func);\r\n            //\r\n            // data.submit() returns a Promise object and allows to attach additional\r\n            // handlers using jQuery's Deferred callbacks:\r\n            // data.submit().done(func).fail(func).always(func);\r\n            add: function (e, data) {\r\n                if (e.isDefaultPrevented()) {\r\n                    return false;\r\n                }\r\n                if (data.autoUpload || (data.autoUpload !== false && $(this).fileupload(\"instance\").option('autoUpload') )) {\r\n                    data.process().done(function () {\r\n                        data.submit();\r\n                    });\r\n                }\r\n            },\r\n\r\n            // Other callbacks:\r\n\r\n            // Callback for the submit event of each file upload:\r\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\r\n\r\n            // Callback for the start of each file upload request:\r\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\r\n\r\n            // Callback for successful uploads:\r\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\r\n\r\n            // Callback for failed (abort or error) uploads:\r\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\r\n\r\n            // Callback for completed (success, abort or error) requests:\r\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\r\n\r\n            // Callback for upload progress events:\r\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\r\n\r\n            // Callback for global upload progress events:\r\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\r\n\r\n            // Callback for uploads start, equivalent to the global ajaxStart event:\r\n            // start: function (e) {}, // .bind('fileuploadstart', func);\r\n\r\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\r\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\r\n\r\n            // Callback for change events of the fileInput(s):\r\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\r\n\r\n            // Callback for paste events to the pasteZone(s):\r\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\r\n\r\n            // Callback for drop events of the dropZone(s):\r\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\r\n\r\n            // Callback for dragover events of the dropZone(s):\r\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\r\n\r\n            // Callback for the start of each chunk upload request:\r\n            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\r\n\r\n            // Callback for successful chunk uploads:\r\n            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\r\n\r\n            // Callback for failed (abort or error) chunk uploads:\r\n            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\r\n\r\n            // Callback for completed (success, abort or error) chunk upload requests:\r\n            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\r\n\r\n            // The plugin options are used as settings object for the ajax calls.\r\n            // The following are jQuery ajax settings required for the file uploads:\r\n            processData: false,\r\n            contentType: false,\r\n            cache: false\r\n        },\r\n\r\n        // A list of options that require reinitializing event listeners and/or\r\n        // special initialization code:\r\n        _specialOptions: [\r\n            'picker',\r\n            'dropZone',\r\n            'pasteZone',\r\n            'multipart',\r\n            'filesContainer',\r\n            'uploadTemplateId',\r\n            'downloadTemplateId'            \r\n        ],\r\n\r\n        _BitrateTimer: function () {\r\n            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());\r\n            this.loaded = 0;\r\n            this.bitrate = 0;\r\n            this.getBitrate = function (now, loaded, interval) {\r\n                var timeDiff = now - this.timestamp;\r\n                if (!this.bitrate || !interval || timeDiff > interval) {\r\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\r\n                    this.loaded = loaded;\r\n                    this.timestamp = now;\r\n                }\r\n                return this.bitrate;\r\n            };\r\n        },\r\n\r\n        _getTotal: function (files) {\r\n            var total = 0;\r\n            langx.each(files, function (index, file) {\r\n                total += file.size || 1;\r\n            });\r\n            return total;\r\n        },\r\n\r\n        _initProgressObject: function (obj) {\r\n            var progress = {\r\n                loaded: 0,\r\n                total: 0,\r\n                bitrate: 0\r\n            };\r\n            if (obj._progress) {\r\n                langx.extend(obj._progress, progress);\r\n            } else {\r\n                obj._progress = progress;\r\n            }\r\n        },\r\n\r\n        _initResponseObject: function (obj) {\r\n            var prop;\r\n            if (obj._response) {\r\n                for (prop in obj._response) {\r\n                    if (obj._response.hasOwnProperty(prop)) {\r\n                        delete obj._response[prop];\r\n                    }\r\n                }\r\n            } else {\r\n                obj._response = {};\r\n            }\r\n        },\r\n\r\n        _onProgress: function (e, data) {\r\n            if (e.lengthComputable) {\r\n                var now = ((Date.now) ? Date.now() : (new Date()).getTime()),\r\n                    loaded;\r\n                if (data._time && data.progressInterval &&\r\n                        (now - data._time < data.progressInterval) &&\r\n                        e.loaded !== e.total) {\r\n                    return;\r\n                }\r\n                data._time = now;\r\n                loaded = Math.floor(\r\n                    e.loaded / e.total * (data.chunkSize || data._progress.total)\r\n                ) + (data.uploadedBytes || 0);\r\n                // Add the difference from the previously loaded state\r\n                // to the global loaded counter:\r\n                this._progress.loaded += (loaded - data._progress.loaded);\r\n                this._progress.bitrate = this._bitrateTimer.getBitrate(\r\n                    now,\r\n                    this._progress.loaded,\r\n                    data.bitrateInterval\r\n                );\r\n                data._progress.loaded = data.loaded = loaded;\r\n                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(\r\n                    now,\r\n                    loaded,\r\n                    data.bitrateInterval\r\n                );\r\n                // Trigger a custom progress event with a total data property set\r\n                // to the file size(s) of the current upload and a loaded data\r\n                // property calculated accordingly:\r\n                this._trigger(\r\n                    'progress',\r\n                    eventer.create('progress', {delegatedEvent: e}),\r\n                    data\r\n                );\r\n                // Trigger a global progress event for all current file uploads,\r\n                // including ajax calls queued for sequential file uploads:\r\n                this._trigger(\r\n                    'progressall',\r\n                    eventer.create('progressall', {delegatedEvent: e}),\r\n                    this._progress\r\n                );\r\n            }\r\n        },\r\n\r\n        _getParamName: function (options) {\r\n            var picker = $(options.picker),\r\n                paramName = options.paramName;\r\n            //if (!paramName) {\r\n            //    paramName = [fileInput.prop('name') || 'files[]'];\r\n            // } else if (!langx.isArray(paramName)) {\r\n\r\n            if (!langx.isArray(paramName)) {\r\n                paramName = [paramName];\r\n            }\r\n            return paramName;\r\n        },\r\n\r\n\r\n        // jQuery 1.6 doesn't provide .state(),\r\n        // while jQuery 1.8+ removed .isRejected() and .isResolved():\r\n        _getDeferredState: function (deferred) {\r\n            if (deferred.state) {\r\n                return deferred.state();\r\n            }\r\n            if (deferred.isResolved()) {\r\n                return 'resolved';\r\n            }\r\n            if (deferred.isRejected()) {\r\n                return 'rejected';\r\n            }\r\n            return 'pending';\r\n        },\r\n\r\n        // Maps jqXHR callbacks to the equivalent\r\n        // methods of the given Promise object:\r\n        _enhancePromise: function (promise) {\r\n            promise.success = promise.done;\r\n            promise.error = promise.fail;\r\n            promise.complete = promise.always;\r\n            return promise;\r\n        },\r\n\r\n        // Creates and returns a Promise object enhanced with\r\n        // the jqXHR methods abort, success, error and complete:\r\n        _getXHRPromise: function (resolveOrReject, context, args) {\r\n            var dfd = new Deferred(),\r\n                promise = dfd.promise;\r\n            context = context || this.options.context || promise;\r\n            if (resolveOrReject === true) {\r\n                dfd.resolveWith(context, args);\r\n            } else if (resolveOrReject === false) {\r\n                dfd.rejectWith(context, args);\r\n            }\r\n            promise.abort = dfd.promise;\r\n            return this._enhancePromise(promise);\r\n        },\r\n\r\n        // Adds convenience methods to the data callback argument:\r\n        _addConvenienceMethods: function (e, data) {\r\n            var that = this,\r\n                getPromise = function (args) {\r\n                    return new Deferred().resolveWith(that, args).promise;\r\n                };\r\n            data.process = function (resolveFunc, rejectFunc) {\r\n                if (resolveFunc || rejectFunc) {\r\n                    data._processQueue = this._processQueue =\r\n                        (this._processQueue || getPromise([this])).pipe(\r\n                            function () {\r\n                                if (data.errorThrown) {\r\n                                    return new Deferred()\r\n                                        .rejectWith(that, [data]).promise;\r\n                                }\r\n                                return getPromise(arguments);\r\n                            }\r\n                        ).pipe(resolveFunc, rejectFunc);\r\n                }\r\n                return this._processQueue || getPromise([this]);\r\n            };\r\n            data.submit = function () {\r\n                if (this.state() !== 'pending') {\r\n                    data.jqXHR = this.jqXHR =\r\n                        (that._trigger(\r\n                            'submit',\r\n                            eventer.create('submit', {delegatedEvent: e}),\r\n                            this\r\n                        ) !== false) && that._onSend(e, this);\r\n                }\r\n                return this.jqXHR || that._getXHRPromise();\r\n            };\r\n            data.abort = function () {\r\n                if (this.jqXHR) {\r\n                    return this.jqXHR.abort();\r\n                }\r\n                this.errorThrown = 'abort';\r\n                that._trigger('fail', null, this);\r\n                return that._getXHRPromise(false);\r\n            };\r\n            data.state = function () {\r\n                if (this.jqXHR) {\r\n                    return that._getDeferredState(this.jqXHR);\r\n                }\r\n                if (this._processQueue) {\r\n                    return that._getDeferredState(this._processQueue);\r\n                }\r\n            };\r\n            data.processing = function () {\r\n                return !this.jqXHR && this._processQueue && that\r\n                    ._getDeferredState(this._processQueue) === 'pending';\r\n            };\r\n            data.progress = function () {\r\n                return this._progress;\r\n            };\r\n            data.response = function () {\r\n                return this._response;\r\n            };\r\n        },\r\n\r\n        _beforeSend: function (e, data) {\r\n            if (this._active === 0) {\r\n                // the start callback is triggered when an upload starts\r\n                // and no other uploads are currently running,\r\n                // equivalent to the global ajaxStart event:\r\n                this._trigger('start');\r\n                // Set timer for global bitrate progress calculation:\r\n                this._bitrateTimer = new this._BitrateTimer();\r\n                // Reset the global progress values:\r\n                this._progress.loaded = this._progress.total = 0;\r\n                this._progress.bitrate = 0;\r\n            }\r\n            // Make sure the container objects for the .response() and\r\n            // .progress() methods on the data object are available\r\n            // and reset to their initial state:\r\n            this._initResponseObject(data);\r\n            this._initProgressObject(data);\r\n            data._progress.loaded = data.loaded = data.uploadedBytes || 0;\r\n            data._progress.total = data.total = this._getTotal(data.files) || 1;\r\n            data._progress.bitrate = data.bitrate = 0;\r\n            this._active += 1;\r\n            // Initialize the global progress values:\r\n            this._progress.loaded += data.loaded;\r\n            this._progress.total += data.total;\r\n        },\r\n\r\n        _onDone: function (result, textStatus, jqXHR, options) {\r\n            var total = options._progress.total,\r\n                response = options._response;\r\n            if (options._progress.loaded < total) {\r\n                // Create a progress event if no final progress event\r\n                // with loaded equaling total has been triggered:\r\n                this._onProgress(eventer.create('progress', {\r\n                    lengthComputable: true,\r\n                    loaded: total,\r\n                    total: total\r\n                }), options);\r\n            }\r\n            response.result = options.result = result;\r\n            response.textStatus = options.textStatus = textStatus;\r\n            response.jqXHR = options.jqXHR = jqXHR;\r\n            this._trigger('done', null, options);\r\n        },\r\n\r\n        _onFail: function (jqXHR, textStatus, errorThrown, options) {\r\n            var response = options._response;\r\n            if (options.recalculateProgress) {\r\n                // Remove the failed (error or abort) file upload from\r\n                // the global progress calculation:\r\n                this._progress.loaded -= options._progress.loaded;\r\n                this._progress.total -= options._progress.total;\r\n            }\r\n            response.jqXHR = options.jqXHR = jqXHR;\r\n            response.textStatus = options.textStatus = textStatus;\r\n            response.errorThrown = options.errorThrown = errorThrown;\r\n            this._trigger('fail', null, options);\r\n        },\r\n\r\n        _trigger : function(type,event,data) {\r\n            var e = eventer.proxy(event);\r\n            e.type = type;\r\n            e.data =data;\r\n            return this.trigger(e,data);\r\n        },\r\n\r\n        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\r\n            // jqXHRorResult, textStatus and jqXHRorError are added to the\r\n            // options object via done and fail callbacks\r\n            this._trigger('always', null, options);\r\n        },\r\n\r\n        _onSend: function (e, data) {\r\n            if (!data.submit) {\r\n                this._addConvenienceMethods(e, data);\r\n            }\r\n            var that = this,\r\n                jqXHR,\r\n                aborted,\r\n                slot,\r\n                pipe,\r\n                send = function () {\r\n                    that._sending += 1;\r\n                    data.url = that.options.url;\r\n                    data.dataType = that.options.dataType;\r\n                    data.xhrFields = that.options.xhrFields;\r\n\r\n                    jqXHR = upload(data);\r\n\r\n                    jqXHR.progress(function(e){\r\n                        //var oe = e.originalEvent;\r\n                        // Make sure the progress event properties get copied over:\r\n                        //e.lengthComputable = oe.lengthComputable;\r\n                        //e.loaded = oe.loaded;\r\n                        //e.total = oe.total;\r\n                        that._onProgress(e, jqXHR.options);\r\n\r\n                    }).done(function (result, textStatus) {\r\n                        that._onDone(result, textStatus, jqXHR, jqXHR.options);\r\n                    }).fail(function (e, textStatus) {\r\n                        that._onFail(jqXHR, textStatus,e, jqXHR.options);\r\n                    }).always(function () {\r\n                        that._sending -= 1;\r\n                        that._active -= 1;\r\n                        that._trigger('stop');\r\n                    });\r\n                    return jqXHR;\r\n                };\r\n            this._beforeSend(e, data);\r\n\r\n            return send();\r\n        },\r\n        _onAdd: function (e, data) {\r\n            var that = this,\r\n                result = true,\r\n                options = langx.extend({}, this.options, data),\r\n                files = data.files,\r\n                filesLength = files.length,\r\n                limit = options.limitMultiFileUploads,\r\n                limitSize = options.limitMultiFileUploadSize,\r\n                overhead = options.limitMultiFileUploadSizeOverhead,\r\n                batchSize = 0,\r\n                paramName = this._getParamName(options),\r\n                paramNameSet,\r\n                paramNameSlice,\r\n                fileSet,\r\n                i,\r\n                j = 0;\r\n            if (limitSize && (!filesLength || files[0].size === undefined)) {\r\n                limitSize = undefined;\r\n            }\r\n            if (!(options.singleFileUploads || limit || limitSize)) {\r\n                fileSet = [files];\r\n                paramNameSet = [paramName];\r\n            } else if (!(options.singleFileUploads || limitSize) && limit) {\r\n                fileSet = [];\r\n                paramNameSet = [];\r\n                for (i = 0; i < filesLength; i += limit) {\r\n                    fileSet.push(files.slice(i, i + limit));\r\n                    paramNameSlice = paramName.slice(i, i + limit);\r\n                    if (!paramNameSlice.length) {\r\n                        paramNameSlice = paramName;\r\n                    }\r\n                    paramNameSet.push(paramNameSlice);\r\n                }\r\n            } else if (!options.singleFileUploads && limitSize) {\r\n                fileSet = [];\r\n                paramNameSet = [];\r\n                for (i = 0; i < filesLength; i = i + 1) {\r\n                    batchSize += files[i].size + overhead;\r\n                    if (i + 1 === filesLength ||\r\n                            ((batchSize + files[i + 1].size + overhead) > limitSize) ||\r\n                            (limit && i + 1 - j >= limit)) {\r\n                        fileSet.push(files.slice(j, i + 1));\r\n                        paramNameSlice = paramName.slice(j, i + 1);\r\n                        if (!paramNameSlice.length) {\r\n                            paramNameSlice = paramName;\r\n                        }\r\n                        paramNameSet.push(paramNameSlice);\r\n                        j = i + 1;\r\n                        batchSize = 0;\r\n                    }\r\n                }\r\n            } else {\r\n                paramNameSet = paramName;\r\n            }\r\n            data.originalFiles = files;\r\n            langx.each(fileSet || files, function (index, element) {\r\n                var newData = langx.extend({}, data);\r\n                newData.files = fileSet ? element : [element];\r\n                newData.paramName = paramNameSet[index];\r\n                that._initResponseObject(newData);\r\n                that._initProgressObject(newData);\r\n                that._addConvenienceMethods(e, newData);\r\n                result = that._trigger(\r\n                    'add',\r\n                    eventer.create('add', {delegatedEvent: e}),\r\n                    newData\r\n                );\r\n                return result;\r\n            });\r\n            return result;\r\n        },\r\n\r\n        _initEventHandlers: function () {\r\n            var that = this;\r\n\r\n            dropzone(this.options.dropZone[0],{\r\n                dropped : function (files) {\r\n                    var data = {};\r\n                    data.files = files;\r\n                    that._onAdd(null, data);\r\n                }\r\n            });\r\n\r\n            pastezone(this.options.pasteZone[0],{\r\n                pasted : function (files) {\r\n                    var data = {};\r\n                    data.files = files;\r\n                    that._onAdd(null, data);\r\n                }\r\n            });\r\n\r\n            picker(this.options.picker[0],{\r\n                multiple: true,\r\n                picked : function (files) {\r\n                    var data = {};\r\n                    data.files = files;\r\n                    that._onAdd(null, data);\r\n                }\r\n            });\r\n        },\r\n\r\n        _destroyEventHandlers: function () {\r\n            //this._off(this.options.dropZone, 'dragover drop');\r\n            //this._off(this.options.pasteZone, 'paste');\r\n            //this._off(this.options.picker, 'change');\r\n        },\r\n\r\n        _setOption: function (key, value) {\r\n            var reinit = langx.inArray(key, this._specialOptions) !== -1;\r\n            if (reinit) {\r\n                this._destroyEventHandlers();\r\n            }\r\n            this._super(key, value);\r\n            if (reinit) {\r\n                this._initSpecialOptions();\r\n                this._initEventHandlers();\r\n            }\r\n        },\r\n\r\n        _initSpecialOptions: function () {\r\n            var options = this.options;\r\n            //if (options.fileInput === undefined) {\r\n            //    //options.fileInput = this.element.is('input[type=\"file\"]') ?\r\n            //    //        this.element : this.element.find('input[type=\"file\"]');\r\n            //    options.fileInput = this.element.find('.fileinput-button');\r\n            \r\n            if (options.picker) {\r\n                if (!(options.picker instanceof $)) {\r\n                    options.picker = $(options.picker,this._elm);\r\n                }                \r\n            }\r\n\r\n            if (options.dropZone) {\r\n                if (!(options.dropZone instanceof $)) {\r\n                    options.dropZone = $(options.dropZone,this._elm);\r\n                }\r\n            }\r\n\r\n            if (options.pasteZone) {\r\n                if (!(options.pasteZone instanceof $)) {\r\n                    options.pasteZone = $(options.pasteZone,this._elm);\r\n                }                \r\n            }\r\n        },\r\n\r\n        _getRegExp: function (str) {\r\n            var parts = str.split('/'),\r\n                modifiers = parts.pop();\r\n            parts.shift();\r\n            return new RegExp(parts.join('/'), modifiers);\r\n        },\r\n\r\n        _isRegExpOption: function (key, value) {\r\n            return key !== 'url' && langx.type(value) === 'string' &&\r\n                /^\\/.*\\/[igm]{0,3}$/.test(value);\r\n        },\r\n\r\n        _construct: function (elm,options) {\r\n            this._elm = elm;\r\n            this.options = langx.mixin({},this.options,options);\r\n            this._initSpecialOptions();\r\n            this._slots = [];\r\n            this._sequence = this._getXHRPromise(true);\r\n            this._sending = this._active = 0;\r\n            this._initProgressObject(this);\r\n            this._initEventHandlers();\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows to query\r\n        // the number of active uploads:\r\n        active: function () {\r\n            return this._active;\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows to query\r\n        // the widget upload progress.\r\n        // It returns an object with loaded, total and bitrate properties\r\n        // for the running uploads:\r\n        progress: function () {\r\n            return this._progress;\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows adding files\r\n        // using the fileupload API. The data parameter accepts an object which\r\n        // must have a files property and can contain additional options:\r\n        // .fileupload('add', {files: filesList});\r\n        add: function (data) {\r\n            var that = this;\r\n            if (!data || this.options.disabled) {\r\n                return;\r\n            }\r\n            data.files = langx.makeArray(data.files);\r\n            this._onAdd(null, data);\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows sending files\r\n        // using the fileupload API. The data parameter accepts an object which\r\n        // must have a files or fileInput property and can contain additional options:\r\n        // .fileupload('send', {files: filesList});\r\n        // The method returns a Promise object for the file upload call.\r\n        send: function (data) {\r\n            if (data && !this.options.disabled) {\r\n                data.files = langx.makeArray(data.files);\r\n                if (data.files.length) {\r\n                    return this._onSend(null, data);\r\n                }\r\n            }\r\n            return this._getXHRPromise(false, data && data.context);\r\n        }\r\n\r\n    });\r\n\r\n\r\n    function uploader(elm,options) {\r\n        var fuInst = new FileUploader(elm,options);\r\n        fuInst.on(\"all\",function(evt,data){\r\n            var typ = evt.type;\r\n            if (langx.isFunction(options[typ])) {\r\n                options[typ].call(fuInst._elm,evt,data);\r\n            }\r\n        });\r\n        return fuInst;\r\n    }\r\n\r\n    return uploader;\r\n\r\n});\r\n\ndefine('skylark-widgets-filer/Uploader',[\r\n  \"skylark-langx/langx\",\r\n  \"skylark-data-collection/ArrayList\",\r\n  \"./domx/uploader\",\r\n  \"skylark-domx-query\",\r\n  \"skylark-widgets-base/Widget\",\r\n  \"./filer\"\r\n]  ,function(langx,ArrayList,uploader, $, Widget,filer){\r\n\r\n    function displaySize(bytes) {\r\n        var sizes = ['B', 'KB', 'MB', 'GB', 'TB'];\r\n        if (bytes == 0) return '0 B';\r\n        var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));\r\n        return (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + sizes[i];\r\n    }\r\n    function displayDate(timestamp) {\r\n        return new Date(timestamp).toLocaleString();\r\n    }\r\n    /**\r\n     * This model represents a file.\r\n     *\r\n     */\r\n    var FileItem = langx.Stateful.inherit({\r\n        state: \"pending\",\r\n\r\n        /**\r\n         * Start upload.\r\n         *\r\n         */\r\n        start: function ()  {\r\n            if (this.isPending()) {\r\n                this.get('processor').submit();\r\n                this.state = \"running\";\r\n\r\n                // Dispatch event\r\n                this.trigger('filestarted', this);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Cancel a file upload.\r\n         *\r\n         */\r\n        cancel: function () {\r\n            this.get('processor').abort();\r\n            this.destroy();\r\n\r\n            // Dispatch event\r\n            this.state = \"canceled\";\r\n            this.trigger('filecanceled', this);\r\n        },\r\n\r\n        /**\r\n         * Notify file that progress updated.\r\n         *\r\n         */\r\n        progress: function (data)  {\r\n            // Dispatch event\r\n            this.trigger('fileprogress', this.get('processor').progress());\r\n        },\r\n\r\n        /**\r\n         * Notify file that upload failed.\r\n         *\r\n         */\r\n        fail: function (error)  {\r\n            // Dispatch event\r\n            this.state = \"error\";\r\n            this.trigger('filefailed', error);\r\n        },\r\n\r\n        /**\r\n         * Notify file that upload is done.\r\n         *\r\n         */\r\n        done: function (result)  {\r\n            // Dispatch event\r\n            this.state = \"error\";\r\n            this.trigger('filedone', result);\r\n        },\r\n\r\n        /**\r\n         * Is this file pending to be uploaded ?\r\n         *\r\n         */\r\n        isPending: function ()  {\r\n            return this.getState() == \"pending\";\r\n        },\r\n\r\n        /**\r\n         * Is this file currently uploading ?\r\n         *\r\n         */\r\n        isRunning: function () {\r\n            return this.getState() == \"running\";\r\n        },\r\n\r\n        /**\r\n         * Is this file uploaded ?\r\n         *\r\n         */\r\n        isDone: function () {\r\n            return this.getState() == \"done\";\r\n        },\r\n\r\n        /**\r\n         * Is this upload in error ?\r\n         *\r\n         */\r\n        isError: function () {\r\n            return this.getState() == \"error\" || this.getState == \"canceled\";\r\n        },\r\n\r\n        /**\r\n         * Get the file state.\r\n         *\r\n         */\r\n        getState: function () {\r\n            return this.state;\r\n        }\r\n    });\r\n\r\n    /**\r\n     * This is a file collection, used to manage the selected\r\n     * and processing files.\r\n     *\r\n     */\r\n    var FileItemCollection = ArrayList.inherit({\r\n        item: FileItem\r\n    });\r\n\r\n    /**\r\n     * A file view, which is the view that manage a single file\r\n     * process in the upload manager.\r\n     *\r\n     */\r\n    var FileItemWidget = Widget.inherit({\r\n        className: 'upload-manager-file row',\r\n\r\n        options : {\r\n          selectors : {\r\n            fileName : \".name\",\r\n            fileSize : \".size\",\r\n            cancel : \".cancel\",\r\n            clear : \".clear\",\r\n            progress : \".progress\",\r\n            message : \".message\"\r\n          }\r\n        },\r\n\r\n        state : {\r\n          fileName : String,\r\n          fileSize : Number\r\n        },\r\n\r\n        _init: function () {\r\n            this.processUploadMsg = this.options.processUploadMsg;\r\n            this.doneMsg = this.options.doneMsg;\r\n\r\n            this.model = this.options.model;\r\n\r\n            this.fileName(this.options.fileName);\r\n            this.fileSize(this.options.fileSize);\r\n\r\n            // Bind model events\r\n            this.model.on('destroy', this.close, this);\r\n            this.model.on('fileprogress', this.updateProgress, this);\r\n            this.model.on('filefailed', this.hasFailed, this);\r\n            this.model.on('filedone', this.hasDone, this);\r\n\r\n            // In each case, update view\r\n            this.model.on('all', this.update, this);\r\n\r\n            // Bind events\r\n            //this.bindEvents();\r\n\r\n            // Update elements\r\n            this.update();            \r\n        },\r\n\r\n        _refresh : function(updates) {\r\n\r\n        },\r\n\r\n        /**\r\n         * Update upload progress.\r\n         *\r\n         */\r\n        updateProgress: function (progress) {\r\n            var percent = parseInt(progress.loaded / progress.total * 100, 10);\r\n            var progressHTML = displaySize(progress.loaded)+' of '+ displaySize(progress.total);\r\n            if (percent >= 100 && this.processUploadMsg) { progressHTML = this.processUploadMsg; }\r\n\r\n            this._velm.$('.progress')\r\n                .find('.bar')\r\n                .css('width', percent+'%')\r\n                .parent()\r\n                .find('.progress-label')\r\n                .html(progressHTML);\r\n        },\r\n\r\n        /**\r\n         * File upload has failed.\r\n         *\r\n         */\r\n        hasFailed: function (error){\r\n            this._velm.$('.message').html('<i class=\"icon-error\"></i> '+error);\r\n        },\r\n\r\n        /**\r\n         * File upload is done.\r\n         *\r\n         */\r\n        hasDone: function (result){\r\n            this._velm.$('.message').html('<i class=\"icon-success\"></i> ' + (this.doneMsg || 'Uploaded'));\r\n        },\r\n\r\n        /**\r\n         * Update view without complete rendering.\r\n         *\r\n         */\r\n        update: function () {\r\n            var selectors = this.options.selectors,\r\n                when_pending = this._velm.$(selectors.size + \",\" + selectors.cancel),\r\n                when_running = this._velm.$(selectors.progress + \",\" + selectors.cancel),\r\n                when_done = this._velm.$(selectors.message + \",\" + selectors.clear);\r\n\r\n            if (this.model.isPending()) {\r\n                when_running.add(when_done).addClass('hidden');\r\n                when_pending.removeClass('hidden');\r\n            } else if (this.model.isRunning()) {\r\n                when_pending.add(when_done).addClass('hidden');\r\n                when_running.removeClass('hidden');\r\n            } else if (this.model.isDone() || this.model.isError()) {\r\n                when_pending.add(when_running).addClass('hidden');\r\n                when_done.removeClass('hidden');\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Startup widget with binding events\r\n         * @override\r\n         *\r\n         */\r\n        _startup: function () {\r\n            var self = this;\r\n\r\n            // DOM events\r\n            this._velm.$(this.options.selectors.cancel).click(function(){\r\n                self.model.cancel();\r\n                self.collection.remove(self.model);\r\n            });\r\n            this._velm.$(this.options.selectors.clear).click(function(){\r\n                self.model.destroy();\r\n                self.collection.remove(self.model);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Compute data to be passed to the view.\r\n         *\r\n         */\r\n        computeData: function () {\r\n            return $.extend({\r\n              displaySize : displaySize,\r\n              displayDate : displayDate\r\n            }, this.model.get('data'));\r\n        }\r\n    });\r\n\r\n\r\n    var Uploader =  Widget.inherit({\r\n        klassName : \"Uploader\",\r\n        pluginName : \"lark.uploader\",\r\n\r\n        options: {\r\n\r\n            uploadUrl: '/upload',\r\n            autoUpload: false,\r\n            selectors : {\r\n              fileList : '.file-list',\r\n              nodata : \".file-list .no-data\",\r\n              pickFiles: '.file-picker',\r\n              startUploads: '.start-uploads',\r\n              cancelUploads: '.cancel-uploads',\r\n            },\r\n\r\n            dataType: 'json',\r\n\r\n            fileItem : {\r\n            \tselectors : {\r\n\r\n            \t},\r\n\r\n            \ttemplate : null\r\n            }\r\n        },\r\n\r\n        state : {\r\n        },\r\n\r\n        /**\r\n         * Render the main part of upload manager.\r\n         *\r\n         */\r\n        _init: function () {\r\n            var self = this;\r\n\r\n\r\n            // Create the file list\r\n            var files = this._files = new FileItemCollection();\r\n\r\n            // Add add files handler\r\n            var filePicker = this._velm.$(this.options.selectors.pickFiles), self = this;\r\n\r\n            this.uploadProcess =  uploader(this._elm,{  //$.$(this.el).fileupload({\r\n                dataType: this.options.dataType,\r\n                url: this.options.uploadUrl,\r\n                formData: this.options.formData,\r\n                autoUpload: this.options.autoUpload,\r\n                singleFileUploads: true,\r\n                picker : filePicker,\r\n\r\n                'add' : function (e, data) {\r\n                    // Create an array in which the file objects\r\n                    // will be stored.\r\n                    data.uploadManagerFiles = [];\r\n\r\n                    // A file is added, process for each file.\r\n                    // Note: every times, the data.files array length is 1 because\r\n                    //       of \"singleFileUploads\" option.\r\n                    langx.each(data.files, function (index, file_data) {\r\n                        // Create the file object\r\n                        file_data.id = self.file_id++;\r\n                        var file = new FileItem({\r\n                            data: file_data,\r\n                            processor: data\r\n                        });\r\n\r\n                        // Add file in data\r\n                        data.uploadManagerFiles.push(file);\r\n\r\n                        // Trigger event\r\n                        //self.trigger('fileadd', file);\r\n                        // Add it to current list\r\n                        self._files.add(file);\r\n\r\n                        // Create the view\r\n                        self.renderFile(file);\r\n\r\n                    });\r\n                },\r\n                'progress' : function (e, data) {\r\n                    langx.each(data.uploadManagerFiles, function (index, file) {\r\n                        //self.trigger('fileprogress', file, data);\r\n\r\n                        file.progress(data);\r\n                    });\r\n                },\r\n\r\n                'fail' : function (e, data) {\r\n                    langx.each(data.uploadManagerFiles, function (index, file) {\r\n                        var error = \"Unknown error\";\r\n                        if (typeof data.errorThrown == \"string\") {\r\n                            error = data.errorThrown;\r\n                        } else if (typeof data.errorThrown == \"object\") {\r\n                            error = data.errorThrown.message;\r\n                        } else if (data.result) {\r\n                            if (data.result.error) {\r\n                                error = data.result.error;\r\n                            } else if (data.result.files && data.result.files[index] && data.result.files[index].error) {\r\n                                error = data.result.files[index].error;\r\n                            } else {\r\n                                error = \"Unknown remote error\";\r\n                            }\r\n                        }\r\n\r\n                        //self.trigger('filefail', file, error);\r\n                        file.fail(error);\r\n                    });\r\n                },\r\n\r\n                'done' : function (e, data) {\r\n                    langx.each(data.uploadManagerFiles, function (index, file) {\r\n                        //self.trigger('filedone', file, data);\r\n                        file.done(data.result);\r\n                    });\r\n                }\r\n\r\n            });\r\n\r\n            // Add upload process events handlers\r\n            this.bindProcessEvents();\r\n\r\n            // Add cancel all handler\r\n            this._velm.$(this.options.selectors.cancelUploads).click(function(){\r\n                while (self._files.length) {\r\n                    self._files.at(0).cancel();\r\n                }\r\n            });\r\n\r\n            // Add start uploads handler\r\n            this._velm.$(this.options.selectors.startUploads).click(function(){\r\n                self._files.forEach(function(file){\r\n                    file.start();\r\n                });\r\n            });\r\n\r\n            // Render current files\r\n            /*\r\n            this.files.forEach(function (file) {\r\n                self.renderFile(file);\r\n            });\r\n            */\r\n\r\n            this._refresh({files:true});\r\n        \r\n\r\n            this._files.on('all', function(){\r\n              self._refresh({files:true});\r\n            });\r\n\r\n        },\r\n\r\n        _refresh : function(updates) {\r\n            var self = this;\r\n            function updateFileList()  {\r\n                var selectors = self.options.selectors,\r\n                    files = self._files;\r\n                var with_files_elements = self._velm.$(selectors.cancelUploads + ',' + selectors.startUploads);\r\n                var without_files_elements = self._velm.$(selectors.nodata);\r\n                if (files.count() > 0) {\r\n                    with_files_elements.removeClass('hidden');\r\n                    without_files_elements.addClass('hidden');\r\n                } else {\r\n                    with_files_elements.addClass('hidden');\r\n                    without_files_elements.removeClass('hidden');\r\n                }\r\n            }\r\n\r\n            if (updates[\"files\"]) {\r\n              updateFileList();\r\n            }\r\n\r\n        },\r\n\r\n        /**\r\n         * Render a file.\r\n         *\r\n         */\r\n        renderFile: function (file) {\r\n            var file_view = new FileItemWidget(\r\n              $(langx.template(this.options.fileItem.template,file.get(\"data\")))[0],\r\n              {\r\n                model: file,\r\n                template : this.options.fileItem.template\r\n            });\r\n            //this._velm.$(this.options.selectors.fileList).append(file_view.render());\r\n            file_view.render();\r\n            file_view.attach(this._velm.$(this.options.selectors.fileList)[0]);\r\n        },\r\n\r\n        /**\r\n         * Bind events on the upload processor.\r\n         *\r\n         */\r\n        bindProcessEvents: function () {\r\n        }\r\n    });\r\n\r\n    return filer.Uploader = Uploader;\r\n});\r\n\ndefine('skylark-widgets-filer/main',[\r\n\t\"./filer\",\r\n\t\"./Uploader\"\r\n],function(filer){\r\n\treturn filer;\r\n});\ndefine('skylark-widgets-filer', ['skylark-widgets-filer/main'], function (main) { return main; });\n\n"]}